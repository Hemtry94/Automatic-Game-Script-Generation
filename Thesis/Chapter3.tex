This chapter will provide a review of the past work on Procedural Content Generation. It will highlight different efforts towards generating levels and rules for games.

\section{Level Generation}
This section will present some of the work related to level generation from academia and industry. Most of previous work didn't talk a lot about generating levels for Puzzle Games but it focus more on Platform genre and Arcade games. The work found about Puzzle Games was limited toward certain games such as Sokoban \cite{sokobanLevelGenerationNew, sokobanLevelGenerationOld}, Cut The Rope \cite{ctrSimulationApproach}, and Fruit Dating \cite{fruitDating}. Even the generic work on Puzzle Games need prior human understanding of the game rules \cite{ctrProgressiveApproach, ctrAutomaticGeneration}.\\\par

Generating levels for Puzzle Games seems interesting but it has lots of problems. Levels must have at least one solution. Every element in the level should be used, adding unused items is a bad design. There is no rules govern Puzzle Games ideas which is different from FPS Genre or any other genre. For example some games may have continuous space where all game actions depend on player skills (Angry Birds, Cut the Rope, and Where's my Water?) while others have discrete space where game actions depend (Fruit Dating, Sokoban, and HueBrix).

\subsection{Puzzle Level Generation}
\gfigure{Screenshot from Sokoban}{sokobanScreenshot}{height=3in}{Images/sokoban}
As there is nothing before like this work, this section will show all previous work that can be slightly related. One of the earliest research in Puzzle Games was by Murase et al.\cite{sokobanLevelGenerationOld} trying to generate well designed solvable levels for Sokoban\cite{sokoban}. Sokoban is an old Japanese puzzle game where your goal is to push some crates towards certain locations as shown in \figref{sokobanScreenshot}. His system consists of 3 stages generate, check, then evaluate.
\begin{itemize} \itemsep0pt \parskip0pt \parsep0pt
	\item \textbf{Generate:} The system generates levels layout using predefined templates and placing them at random positions. Goal areas are placed afterwards at random position avoiding placing it at places where player can't push object towards it. For boxes placement more processing is done, as he choose random position that is reachable from the goal area.
	\item \textbf{Check:} The system then uses \newnom{Breadth First Search}{BFS} to check for solution for the generated levels an remove all unsolvable levels.
	\item \textbf{Evaluate:} The system check all the legal candidate levels and remove levels with very short solution, less than four direction changes in the solution, or no detours in the solution.
\end{itemize}
The system generated levels around 500 levels but only 14 are marked as good levels. The generated levels have short solution sequence due to the usage of BFS.\\\par

Taylor and Parberry\cite{sokobanLevelGenerationNew} followed Yoshio Murase et al.\cite{sokobanLevelGenerationOld} work in generating levels for Sokobon game. He followed a system similar to previous consists of 4 stages generating empty room, placing goals, finding the farthest state, then evaluating generated levels.
\begin{itemize} \itemsep0pt \parskip0pt \parsep0pt
	\item \textbf{Generating empty room:} The system generate the size of empty rooms then using predefined 3x3 templates, it starts creating the layout of the level. Generated levels are discarded if they are not completely connected, they have huge empty space, the number of empty floors is less than planned number of boxes and goals, there
	\item \textbf{Placing goals:} The system places goal areas using brute force algorithm to try every possible combination for goals.
	\item \textbf{Finding the farthest state:} The system tries to find farthest position from goal area using a similar algorithm to BFS. The algorithm continues till no more possible locations  can be found. It returns the farthest locations using a box line metric heuristic which calculates the number of unrepeated moves after each other.
	\item \textbf{Evaluating generated levels:} The system evaluates the generated levels and give each one score based on some heuristics. For example: number of box pushes in the solution, number of levels found at same depth, number of box lines, number of boxes, and ...etc.  
\end{itemize}
The generated levels by system using single box are generally uninteresting and as the number of boxes increased they become more interesting and more difficult but takes more time to generate.

\gfigure{Screenshot from Fruit Dating}{fdScreenshot}{width=4in}{Images/fruitDatingScreenshot}

Rychnovsky\cite{fruitDating} worked on generating puzzle levels layout for his new game Fruit Dating. As shown in \figref{fdScreenshot}, Fruit Dating is a puzzle game where the player need to make all similar fruits meet each other. In order to move objects in the level player can swipe in one of the four direction (up, down, left, right). Swiping in any direction cause all level object to move toward that direction. The game sounds simple but with different kind of objects, it become very difficult. His system starts with generating level layout utilizing symmetry when generating two walls at a time. The system generates fruits at random locations based on predefined weights. For example placing fruits is more preferable at the end of corridors, followed by corners, followed by corridors, and last thing is open area. Other game objects are placed with the same strategy but using different weights for different locations. The system tries to solve the generated level and return the solution using an algorithm similar to BFS. Rychonovsky made a level editor to edit the generated levels and test for playability using autosolver algorithm. The technique doesn't take more than couple of minutes to generate a level but the main problem is there is no way to know the difficulty of level before generating it or even influence difficulty in the generation.

\gfigure{Screenshot from Cut The Rope game}{ctrScreenshot}{height=4in}{Images/CutTheRope}

Shaker et al.\cite{ctrAutomaticGeneration} worked on generating levels for physics based puzzle games and applied his output on \newnom{Cut The Rope}{CTR}. As shown in \figref{ctrScreenshot}, CTR goal is to cut some ropes to free the candy to reach OmNom (a frog monster fixed at certain position on the screen). The game is not as easy as it sounds as levels advanced more components are introduced which affect on the movement of the candy to redirect it to OmNom. Shaker used Grammar Evolution to generate levels for the game where he enforced at least one object from each game component. Shaker used a fitness function completely depending on how CTR levels are designed. For example: Candy should be placed higher than the Om Nom, Om Nom must be placed below the lowest rope, and ...etc. He generated 500 levels and then show some analysis on the expressive range of the generator such as frequency, density, and ...etc. Since there is nothing to make sure the level is playable, so Shaker modified the fitness function with a score generated from random player plays the generated level. If the random player couldn't solve the generated level in 10 trials or less, the fitness is decreased by large number to indicate that level is unplayable. Shaker generated 100 playable levels using and show there expressive range which didn't change a lot from the previous.\\\par

Shaker et al.\cite{ctrSimulationApproach} conducted their research and developed a AI to simulate game playing better than random player in the previous paper\cite{ctrAutomaticGeneration}. He introduced two kind of AI, the first one takes actions based on the current properties of components in the level, while the second one depends on reachability of the components by the candy based on its current position and velocity and direction. The levels generated from this paper are more diverse from the previous because random agent may discard some potential levels.\\\par

Shaker et al.\cite{ctrProgressiveApproach} started working on reducing the time for his generating levels in 2015. He introduced a new search technique named Progressive Approach. Shaker uses GA to evolve timeline of game events. This evolved timeline is evaluated by simulating the game and following the timeline. An intelligent agent is used during the simulation utilizing prior knowledge about the game to map the timeline to a possible level layout. If the agent succeed it return the layout, else it returns invalid. This technique can be used on any kind of games to improve generation time, so he tested it on CTR. The results was better than simulation approach as this technique took on average 9.79 seconds to generate a level while previous one \cite{ctrSimulationApproach} took around 82 seconds, the only drawback that you can't know the difficulty of the level from the timeline, you need to simulate it to evaluate level difficulty.\\\par

\gfigure{Screenshot from KGoldRunner}{kgrScreenshot}{width=4in}{Images/kGoldRunner}

Williams-King et al.\cite{kgrAutomaticGeneration} started working on generating levels for their game KGoldRunner. KGoldRunner is just a port for the famous game Lode Runner. As shown in \figref{kgrScreenshot}, your aim is to gold all gold chunks in the level and leave it without getting killed. You can walk left and right, climb ladder, move on bar, and Dig the floor. The game sounds easy but what makes it difficult is the presence of enemies who can change the position of gold chunks. To get the gold from the enemy you should trap him in a hole to drop the gold chunk. After collecting all the gold coins a hidden ladder appear which lead the player to the end of the level. Williams-King used GA to generate random levels and evaluate it using fitness function based on prior knowledge about the game. The fitness function is in favor of generating gold chunks that can be reached and can reach the exit, generating more gold chunks, generating starting node that can reach the exit, not generating lots of enemies, and ...etc. To check for connectivity BFS is used assuming ground is destructible. Levels that get a good fitness are simulated using an AI that tries to collect all gold chunks using 20 different paths. If there is too much paths to solve the level, then its easy level. If there is no path to solve, then its invalid level. Also the system can take user level layout and modify on it to generate a good level. As the number of generation used increase more time is required but the levels generated are more likely to be solvable. Also static fitness function value increase as the level is more likely to be solved. 

\gfigure{Screenshot from Refraction}{refractionScreenshot}{width=4in}{Images/refraction}

Adam M. Smith et al.\cite{refractionStudy} tried to generate puzzle levels for Refraction game using declarative programing. Refraction is an educational game created by Center for Games Science at the University of Washington. Refraction teaches children concepts in math through a puzzle game. As shown in \figref{refractionScreenshot}, the main idea is to make every alien spaceship fully powered by laser. Each ship needs a fraction of laser to operate. Player should use tool like Benders (change the direction of laser by $90^{\circ}$), Splitters (divide laser power by number of outputs from it), and ...etc. Adam M. Smith et al. divided his generator into 3 main components: Mission Generation (generate a general outline showing how levels should be solved), Level Embedder (responsible for translating the general outline to geometric layout), and Puzzle Solver (make sure there is a solution for the generated level). They implemented them into two different ways: Algorithm, \newnom{Answer Set Programming}{ASP} and compared the results. In quantitative aspect the ASP was faster than Algorithmic approach specially in Puzzle Solver. In qualitative aspect the ASP generate less diverse levels than Algorithmic approach. 

\subsection{Other Level Generation}
This section is going to shade some light on Level Generation for all types of games except Puzzle games. The previous work in that field varies for lots of game types specially for Platformer. Showing some of the work will help in understanding the current research direction towards Level Generation.\\\par

Constructive approach in PCG has been used in commercial games for long time. It had been used in generating textures, trees, and even levels. Rami Ismail and Jan Willem Nijman\cite{nuclearThrone} used an Agent Based PCG to generate levels for their commercial game \emph{"Nuclear Throne"}. Each agent has a probability to change his direction and another probability to spawn another agent. Agent kill itself when number of dug floors reached 110. Tom Coxon\cite{lennaInception} used perlin noise and cellular automata algorithm to generate a huge map outline for his commercial game \emph{"Lenna's Inception"}. The game map is divided into screens and perlin noise is used to define the layout for each screen. Cellular Automata Algorithm is used to craft details for each screen and ensure there is path between entrance and exits for each room.\\\par

Search algorithms (specially GA) has been used a lot in level generation. Preuss et al.\cite{goodDiverseLevels} used 3 different search techniques to generate diverse game maps for strategy games. They used Restart Evolution Strategies, Novelty Search, and Niching Evolutionary Algorithm and compared their results in the end. They used 3 metrics for fitness function: Tile Based Distance (measure diversity between each two maps), Objective-based Distance (measure the quality of the map and playability according some heuristics for Strategy games), and Visual Impression Distance (measure how good the map look using 20 different heuristic measures). Niching Evolutionary Algorithm generated bested results in diversity and quality if the fitness function is well designed, followed by Restart Evolution Strategies which is same and sometimes slightly better, while Novelty Search was worst of them in both quality and diversity.\\\par

Liapis et al.\cite{noveltySearch} improved Novelty Search Algorithm to generate better and diverse maps for strategy games than previous work\cite{goodDiverseLevels}. The improved algorithm works on two populations: Feasible, Infeasible. Each population is evolved on its own using crossover and mutation. Chromosomes can transfer from Feasible to Infeasible population and vice versa. Each population have a different fitness function. Feasible population tries to explore more in the Feasible domain and generate more diverse levels so it depends on the distance between the chromosomes. While the Infeasible domain has two different fitness functions, each one tested on its own. The first one is same like the feasible domain where it tries to reach new level designs. The second one use distance toward feasibility as fitness measure. The results shows the first technique generates more feasible solution but less diverse and it can reach feasibility faster.\\\par

Baghdadi et al.\cite{spelunkyLevelGeneration} used Genetic Algorithm to generate levels for the commercial game \emph{"Spelunky"}\cite{spelunky} with a certain difficulty. Level layout is generated by dividing the entire map into 4x4 rooms. The start room must sit in one of the two top rows while the end room must be in one of the two bottom rows. After choosing start and end rooms a path is generated between them. An Agent Based PCG is used to dig each room using 35 tiles. After digging ends some corridors are added to ensure connection between rooms. Monsters and ladders are bombs are added to the level ensuring it is equally distributed using an agent. Each level is measured using fitness function consists of two parts; one part ensure playability while other for difficulty of generated level. The results shows that technique can generate a good levels for Spelunky game with required difficulty.\\\par

Commercial games use template generation to ensure the high quality of the generated game. Derk Yu and Andy Hull\cite{spelunkyTechnique} divide Spelunky map into 4x4 tiles. Each tile is chosen from a set of predefined tiles ensuring there is a path between start point and end point. The generator changes the selected tile by using a constructive approach without blocking any path. Enemies and items are added after layout is generated. Also Edmund Mcmillen\cite{theBindingOfIsaacTechnique} used a similar technique for his commercial game \emph{"The Binding of Isaac"}. Using patterns grabbed the attention of many researcher in generating levels.\\\par

Dahlskog and Togelius\cite{superMarioPattern1, superMarioPattern2, superMarioPattern3, superMarioPattern4} published several work on generating levels for Super Mario Bros game utilizing patterns found in the original game. They started\cite{superMarioPattern1} by analyzing all levels originally designed for Super Mario Bros and divide it into 5 main Macro Patterns (Enemies, Gaps, Valleys, Multiple Paths, and Stairs). Each Macro Pattern is divide into multiple configurations called Meso Patterns, for example Enemies pattern can appear as Enemy (single enemy), 2-Horde (two enemies together), 3-Horde (three enemies together), 4-Horde (four enemies together), and Roof (Enemies underneath hanging platform). The level generator tries to generate levels by randomly choosing one of the patterns and generate geometry corresponding to it. The result of that technique generated levels have same feeling like the original Super Mario Bros. They conducted their research\cite{superMarioPattern2, superMarioPattern3} to improve the quality of generated levels by using these analyzed patterns as a evaluation function instead of generation. The level is divided into vertical slices called Micro Patterns randomly selected from Super Mario Bros. Genetic Algorithm is used to improve the generated levels using fitness function that reward levels which contains some of the known patterns. The results of that methodology are more similar to original generated levels from Super Mario Bros and more diverse. 

Shaker and Abou-Zleikha\cite{nmfSuperMarioBros} used \newnom{Non-Negative Matrix Factorization}{NMF} technique to capture the patterns of level design of Super Mario Bros. That technique can be used on any game if it has a huge amount of levels to learn the pattern from them using NMF. They used 5 different PCG techniques to generate 5000 levels for Super Mario Bros (1000 each technique). NMF method factorize these levels into two new matrices: Pattern Matrix and Weight Matrix. Pattern Matrix can be used to generate same levels like any of the input generators if the weight matrix is used. They compared the results from their technique by the input generators and find out the amount of content generated is more diverse and huger than all 5 of them combined but nothing to proof if these levels are good for player experience.\\\par

Snodgrass and Ontañón\cite{markovSuperMarioBros} used Markov Chain Model to generate levels for Super Mario Bros. Markov Chain Model is used to learn more about the pattern used in designing the levels. The technique can be used on different game genres if there is a huge amount of highly designed levels existing. They tested the technique with different input parameter and evaluate the generated levels using human authors. Using best input configuration only 44\% of generated games where playable with 0\% error in tile configuration.\\\par

\section{Rule Generation}

\section{General Video Game Playing}