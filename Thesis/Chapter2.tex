This chapter presents required background information needed to understand this thesis. It starts with explaining Puzzle Genre in Video Games, followed by description of Procedural Content Generation and a special case called Search Based PCG. It is conducted by describing Video Game Description Language and why it is important. Finally, it explains General Video Game Playing and its relation to this research.

\section{Puzzle Genere in Video Games}
In 1950 a small group of academic people started developing Video Games on the main frames of their schools. This has continued to till the 1970s when Video Games reached Main Stream industry. In 1980s lots of technicals problems were solved which brought new types of Video Games. Game Genres were invented to differentiate between different game types so players can refer to their favorite games by genres, for example there is Adventure genre like Legend of Zelda, Fighting genre like Street Fighter, Platformer genre like Super Mario Bros, Shooter genre like Space Invaders, Puzzle Genre like Bomberman and ...etc. In 2000s people started to go toward being mobile and making games for cellular  phones and one of the most important genres on these mobile devices is Puzzle Genre\cite{pcgHistory}.\\\par

Puzzle Genre is a style of Video Games that emphasize solving puzzles, it always focuses on logical or conceptual challenges. Puzzle games can be described using the following aspects:
\begin{itemize} \itemsep0pt \parskip0pt \parsep0pt
	\item \textbf{Graphics:} How the game looks like.
  	\item \textbf{Inputs:} How input is given to the game.
  	\item \textbf{Rules:} How the game behaves to events.
  	\item \textbf{Levels:} How objects are placed.
  	\item \textbf{Win Condition:} How to end the game.
\end{itemize}

\section{Procedural Content Generation}
\newnom{Procedural Content Generation}{PCG} means generating game content using a computer. It was first developed due to technical limitations (small disk space) and the need to provide a huge amount of content. \emph{Akalbeth} was the first game using PCG, the game starts asking the player to provide it with a lucky number that is used as a seed to a random number generator which generates everything in the game from the player statistics to dungeon maps. Due to that the game has a very small footprint around 22 Kb so it does not need to be loaded from lots of disks \cite{pcgFirstGame}. Although technical difficulties become history and storage is no longer a problem, PCG is still one of the hot topics in Video Games Industry and Research. PCG helps us reduce development time and cost, be creative, and understand the process of creating game content. PCG can be used to generate different game aspects for example Textures, Sounds, Music, Levels, Rules, and ...etc. In this thesis we will focus only on the Levels and Rules Generation which is the core aspect for any Puzzle Game.
\subsection{Level Generation}
Levels are different combination of game objects. These combinations control the game flow and difficulty. For example in Super Mario, as the game advances the levels become longer and include more enemies and gaps. Level Generation has been in industry since dawn of games in order to decrease the game size, but it is now used to introduce huge amount of levels that humans can not generate manually in reasonable time. Level Generation has always been done for a specific game using lots of hacks to improve the output result. These hacks cause the output levels to follow certain guidelines which may cause elimination of huge amounts of possible levels but on the other hand these guidelines ensure that the output levels are all playable (can reach goal of the game) and satisfactory by all players \cite{mcGenerateEverything}.
\subsection{Rule Generation}\seclbl{ch2RG}
Rules are what governs game behavior. Based on them you can know how the game will be played; for example what to collect, what to avoid, how to kill enemies ...etc. Rules are very different from one game genre to another, for example in Board Games (e.g. Monopoly) all rules are applied after player plays his turn, while in Platformer Games (e.g. Super Mario) the rules are applied with every time step (not depending on the player movement). Due to that huge difference between rules in different genres, Rule Generation is one of the most difficult contents to generate. That is why we need to find a way to represent and describe rules. The only way to represent all different genres is using Coding Languages because Coding is the only common thing between all games. Generating new Rules using Coding Languages may take years because Coding Languages are used to create any computer related software such as plug-ins, programs, viruses, games and ...etc. Still some researchers managed to use it but it will need more guidance due to the huge search space of Coding Languages \cite{mechanicMiner}. A better solution is to use a description language for the rules that is more specific for a certain genre which we are going to discuss in \secref{vgdl} \cite{pcgBookRules}.
 
\section{Search Based PCG}
There are many approaches to generate content in Video Games. The search based approach is one famous technique that has been used a lot in recent research. The search based approach can be divided into three main parts Search Algorithm, Content Representation, and Evaluation Function \cite{pcgBookSearch}.
\subsection{Search Algorithm}\seclbl{searchAlgorithm}
This is the \emph{Engine} for generating game content. There are different searching algorithm for example Simulated Annealing, Hill Climbing, and \newnom{Genetic Algorithm}{GA}. GA is a search algorithm based on Darwin Theory \textit{"Survival for the Fittest"}. GA uses techniques inspired from natural evolution such as selection, crossover and mutation in order to find solution to large space optimization problems \cite{geneticAlgorithm}.
\subsection{Content Representation}
There are several ways for modeling different aspect of the game content during the generation process. The way of representing the content can affects a lot on the output of the generation. For example levels may be represented as:\cite{pcgBookSearch}
\begin{itemize}\itemsep0pt \parskip0pt \parsep0pt
	\item 2D matrix where each value represent a tile location in the level.
	\item Sequence of position of objects in level.
	\item Sequence of level Patterns.
	\item Level properties such as Number of Objects in map, Number of Players and ...etc.
	\item Random number seed.
\end{itemize}
\subsection{Evaluation Function}
Without Evaluation Function the Search Algorithm will be blind. The evaluation function leads the Search Algorithm to find better content in the solution space. The evaluation Function can be either one of the following:\cite{pcgBookSearch}
\begin{itemize}\itemsep0pt \parskip0pt \parsep0pt
	\item \textbf{Direct evaluation function:} which utilizes some understanding about the generated content and evaluates it accordingly.
	\item \textbf{Simulation-based evaluation function:} Use Artificial Intelligence agent to test the generated content and based on his behavior it estimates its quality.
	\item \textbf{Interactive evaluation function:} Evaluate generated content based on the interaction with human.
\end{itemize}

\section{Puzzle Script as Video Game Description Language}\seclbl{vgdl}
Referring to \secref{ch2RG} we can not generate game rules without having a methodology to describe it. \newnom{Video Game Description Language}{VGDL} was originally invented to help on the work for General Video Game Playing (discussed later in \secref{GVGPSection}) at Standford University which will be discussed in the following section. The idea behind VGDL was to provide a simple description language that can be used to describe simple 2D games. Researchers insist that any VGDL language must have the following aspects:\cite{vgdl}
\begin{itemize}\itemsep0pt \parskip0pt \parsep0pt
	\item \textbf{Human Readable:} It must be easy for human user to understand games written with it and formulate new one.
	\item \textbf{Unambiguous and Easy to parse:} It must be easy to parse using a computer that is why it must be clear.
	\item \textbf{Searchable:} The games formulated using it can be drawn in form of tree so its easy to use Search Algorithm (discussed in \secref{searchAlgorithm}) to find new games.
	\item \textbf{Expressive:} It can be used to express more than one game.
	\item \textbf{Extensible:} It can be extended to add more game types and dynamics.
	\item \textbf{Viable for Random Generation:} Each component of the language have 'sensible defaults' so its easier to search for new values for certain components without worrying about other ones.
\end{itemize}

\newnom{Puzzle Script}{PS} is a VGDL created by Stephan Lavelle to help game designers and developers to create puzzle games \cite{puzzleScript}. Games generated by PS are time stepped games similar to Sokoban game; Sokoban is an old Japanese puzzle game where your goal is to push some crates towards certain locations \cite{sokoban}. PS file starts with some meta data like game name, author name, and website then it is divided into 7 sections objects, legend, sounds, collision layers, rules, win conditions, and levels. \figref{psFile} shows an example of the PS file for Sokoban game. It is refereed to it in the next sections.
\subsection{Objects}\seclbl{objectSection}
It is the first section of the PS file and it contains a list for all the object names and colors being used in the game for example in \figref{psFile} we had Background, Target, Wall, Player, and Crate associated with a color.
\subsection{Legend}\seclbl{legends}
It is a table of one letter abbreviation and one or more group of objects for example in \figref{psFile} the Wall is assigned "\#" symbol and Crate and Target together are assigned "@" symbol.
\subsection{Sounds}
It consists of group of game events associated with a certain number. PS engine use these numbers as parameter to BFXR to generate sounds in runtime\cite{bfxr} for example in \figref{psFile} Move event for Crate object is assigned to value 36772507.
\subsection{Collision Layers}\seclbl{colLayers}
It defines which objects can not exists at same location during running the game, Objects on the same line can not exist together. Each line is considered a new layer, for example in \figref{psFile} Player, Crate, and Wall can not exists at same location as they are assigned to the same layer.
\subsection{Rules}
Its a set of production rules that govern how the game will be played. Production rules have the following formate
\begin{center}{Tuple ... Tuple -> Tuple ... Tuple}\end{center}
where the number of tuples on the right must be equal to number of tuples on the left, and each tuple must be in the following format
\begin{center}{[Objects | ... | Objects]}\end{center}
Each tuple has a group of Objects separated by "|" symbol which means that these objects are beside each other for example [Player | Crate] means there is a Player and Crate object beside each other. The number of "|" in both left and right side of each tuple must be equal. Objects must be written in the following format
\begin{center}{Direction Object ... Direction Object}\end{center}
Object must be selected from the Objects section and must be from different collision layer for example [Player Target] means Player and Target exists on same tile. Last thing is the Direction, it must be one of the following ">", "<", "$\wedge$", and "$\vee$". The first one means in same as the moving direction, the second one means opposite to moving direction, while the third means $90^{\circ}$ from the moving direction, and the final one is $-90^{\circ}$ from the moving direction. Let's take a real example on the rule, for example in \figref{psFile} the rule is
\begin{center}{[> Player | Crate] -> [> Player | > Crate]}\end{center}
means if there is a Player and Crate beside each other, and the Player moves towards the Crate, then both the Player and the Crate will move in the same direction.
\subsection{Win Conditions} 
It identifies when the level should end. It consists of 2 objects separated by on keyword. For example in \figref{psFile} "all Target on Crate" means that the level ends when all Targets are on same location with Crates. The possible keywords that can be used are "all", "some", and "no". "all" means every single object must be at same location, while "some" means at least one object at same location, but "no" means that the two objects must not be at same location.
\subsection{Levels}
They are 2D matrices showing the current configuration for each game level using the abbreviations found in the Legends section. Each level is separated from the next level by a new line. In \figref{psFile} you can see 3 designed Sokoban levels. By replacing each symbol by the corresponding object from the Legend section then the color from Objects section, so you will get the following levels in \figref{psFileLevels}. 
\gfigure{Puzzle Script Levels}{psFileLevels}{width=1.5in}{Images/psFileLevel}
\newpage
\gfigure{Puzzle Script File}{psFile}{height=9.0in}{Images/PuzzleScript}

\section{General Video Game Playing}\seclbl{GVGPSection}
\newnom{General Video Game Playing}{GVGP} is an area in \newnom{Artifical Intelligence}{AI} where people try to develop an intelligent agent that is able to play more than one game. Most of Game Playing Agents are not general players, they are designed for a certain game like Chess, Poker, Backgammon, or ...etc. At the beginning the AI is supported with game rules in form of VGDL \secref{vgdl} with current game state and possible actions and the agent should choose the next action. After several play-outs the agent should learn how to maximize his score or reach goal and avoid death. Researchers used different methods to try to create general AI using Monte Carlo Tree Search, Neural Networks, and Reinforcement Learning methods. GVGP is very important for PCG specially for rule and level creation because in order to generate good random level or rule, it is better to test it out using a GVGP Agent to have a better judgment on how the random content will be played.\cite{gvgp}